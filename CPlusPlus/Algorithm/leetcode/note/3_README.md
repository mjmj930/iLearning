```cpp
int lengthOfLongestSubstring(std::string s) {
    std::vector<int> last_pos(128,-1);
    int max_len = 0;
    int left = 0;

    for (int right=0; right < s.size(); ++right) {
        char c = s[right];
        if(last_pos[c] != -1 && last_pos[c] >= left) {
            left = last_pos[c] + 1;
        }

        last_pos[c] = right;
        max_len = std::max(max_len, right - left + 1);
    }
    return max_len;
}
```



`last_pos` 数组与无重复子串长度的关联是通过 **动态维护窗口的左右边界** 实现的。具体来说，`last_pos` 记录了每个字符最后一次出现的位置，这使得算法能够快速判断当前字符是否在窗口内重复，并动态调整窗口左边界，从而确保窗口内的字符始终唯一。以下是分步解释：

---

### **1. 核心逻辑**

• **窗口定义**：窗口由 `[left, right]` 表示，其中 `right` 指针逐步右移。
• **`last_pos` 的作用**：存储每个字符 **最后一次出现的位置**。
• **关键操作**：

1. 当 `s[right]` 的字符在窗口内重复时，移动 `left` 到重复字符的下一个位置。
2. 更新 `last_pos[s[right]]` 为当前 `right`。
3. 计算当前窗口长度 `right - left + 1`，并更新最大长度。

---

### **2. 分步示例：以 `s = "abba"` 为例**

#### **(1) 初始化**

• `last_pos` 数组全为 `-1`，表示所有字符未出现过。
• `left = 0`，`max_len = 0`。

| 变量/状态    | 值          |
| ------------ | ----------- |
| `last_pos` | 全为 `-1` |
| `left`     | 0           |
| `max_len`  | 0           |

#### **(2) 处理字符 `'a'`（`right = 0`）**

• 检查 `last_pos['a']`（即 `last_pos[97]`）：
  • `last_pos['a'] = -1` → 无重复。
• 更新 `last_pos['a'] = 0`。
• 计算窗口长度：`0 - 0 + 1 = 1`，更新 `max_len = 1`。

| 变量/状态         | 值 |
| ----------------- | -- |
| `last_pos['a']` | 0  |
| `left`          | 0  |
| `max_len`       | 1  |

#### **(3) 处理字符 `'b'`（`right = 1`）**

• 检查 `last_pos['b']`（即 `last_pos[98]`）：
  • `last_pos['b'] = -1` → 无重复。
• 更新 `last_pos['b'] = 1`。
• 计算窗口长度：`1 - 0 + 1 = 2`，更新 `max_len = 2`。

| 变量/状态         | 值 |
| ----------------- | -- |
| `last_pos['b']` | 1  |
| `left`          | 0  |
| `max_len`       | 2  |

#### **(4) 处理字符 `'b'`（`right = 2`）**

• 检查 `last_pos['b']`：
  • `last_pos['b'] = 1`（非 `-1` 且 `1 >= left=0`）→ 重复！
• 调整 `left = 1 + 1 = 2`。
• 更新 `last_pos['b'] = 2`。
• 计算窗口长度：`2 - 2 + 1 = 1`，`max_len` 保持 `2`。

| 变量/状态         | 值 |
| ----------------- | -- |
| `last_pos['b']` | 2  |
| `left`          | 2  |
| `max_len`       | 2  |

#### **(5) 处理字符 `'a'`（`right = 3`）**

• 检查 `last_pos['a']`：
  • `last_pos['a'] = 0`（非 `-1`，但 `0 < left=2`）→ 不重复！
• 更新 `last_pos['a'] = 3`。
• 计算窗口长度：`3 - 2 + 1 = 2`，`max_len` 保持 `2`。

| 变量/状态         | 值 |
| ----------------- | -- |
| `last_pos['a']` | 3  |
| `left`          | 2  |
| `max_len`       | 2  |

---

### **3. 关键关联点**

#### **(1) `last_pos` 用于检测重复**

• 通过 `last_pos[c] != -1` 判断字符 `c` 是否出现过。
• 通过 `last_pos[c] >= left` 判断字符 `c` 是否在当前窗口内重复。

#### **(2) 窗口长度的动态计算**

• 每次右指针移动后，窗口长度为 `right - left + 1`。
• 最大长度 `max_len` 始终记录窗口长度的最大值。

#### **(3) 更新 `last_pos` 的逻辑**

• 无论是否重复，都要更新 `last_pos[c] = right`，以便后续判断。

---

### **4. 总结**

• **`last_pos` 的核心作用**：记录字符的最后出现位置，帮助快速判断重复。
• **滑动窗口的调整**：通过 `last_pos` 动态移动左边界，确保窗口内无重复字符。
• **最大长度的维护**：每次窗口扩展或调整后，更新 `max_len` 为当前窗口长度和历史最大值的较大者。

通过这种机制，`last_pos` 数组与无重复子串长度直接关联，使得算法高效地找到最长无重复子串。
