构造函数写法：

### 1. 初始化方式

- **使用赋值语句初始化（第一种写法）**

```cpp
Person(std::string n, int a) {
    name = n;
    age = a;
    std::cout << "Person object created." << std::endl;
}
```

在这种写法中，构造函数的函数体里使用赋值语句对成员变量进行初始化。也就是说，成员变量首先会被默认初始化，然后再通过赋值操作将传入的参数值赋给它们。例如，`name` 和 `age` 会先默认初始化，接着再把 `n` 和 `a` 的值赋给它们。

- **使用成员初始化列表初始化（第二种写法）**

```cpp
Person(std::string n, int a) : name(n), age(a) {}
```

这种写法使用成员初始化列表来初始化成员变量。成员初始化列表位于构造函数的参数列表之后、函数体之前，用冒号 `:` 分隔。在成员初始化列表中，成员变量会在对象创建时直接被初始化为指定的值，而不是先默认初始化再赋值。

### 2. 执行顺序

- **使用赋值语句初始化**
  成员变量先进行默认初始化，然后在构造函数体里执行赋值操作。例如，如果 `name` 是 `std::string` 类型，它会先默认构造一个空字符串，然后再把 `n` 的值赋给它。
- **使用成员初始化列表初始化**
  成员变量在对象创建时就直接使用成员初始化列表中的值进行初始化，避免了默认初始化和后续赋值的额外开销。成员变量的初始化顺序是按照它们在类中声明的顺序进行的，而不是成员初始化列表中出现的顺序。

### 3. 适用场景

- **使用赋值语句初始化**
  当成员变量需要在初始化过程中进行一些额外的计算或者逻辑判断时，使用赋值语句初始化会更合适。例如：

```cpp
class Person {
private:
    std::string name;
    int age;
    bool isAdult;
public:
    Person(std::string n, int a) {
        name = n;
        age = a;
        isAdult = (age >= 18);
    }
};
```

在这个例子中，`isAdult` 成员变量需要根据 `age` 的值进行判断，所以使用赋值语句初始化更方便。

- **使用成员初始化列表初始化**
  对于以下几种情况，建议使用成员初始化列表：
  - **常量成员变量**：常量成员变量必须在初始化时赋值，且之后不能再修改，所以只能使用成员初始化列表进行初始化。例如：

```cpp
class Person {
private:
    const int id;
public:
    Person(int i) : id(i) {}
};
```

    -**引用成员变量**：引用必须在初始化时绑定到一个对象，且之后不能再改变绑定的对象，因此也只能使用成员初始化列表进行初始化。例如：

```cpp
class Person {
private:
    std::string& refName;
public:
    Person(std::string& n) : refName(n) {}
};
```

    -**基类的构造函数调用**：在派生类的构造函数中，需要调用基类的构造函数来初始化基类部分，这时也需要使用成员初始化列表。例如：

```cpp
class Base {
public:
    Base(int value) {}
};

class Derived : public Base {
public:
    Derived(int val) : Base(val) {}
};
```

综上所述，成员初始化列表通常比赋值语句初始化更高效，特别是对于常量成员变量、引用成员变量和基类的构造函数调用。但在需要进行额外计算或逻辑判断时，使用赋值语句初始化会更合适。
